---
title: "Claude Code Skills"
description: "孵化你的 Claude Code Skill 体系"
create_time: 2026-01-06 00:00
tags:
  - tech
published: true
---

每个人的工作内容，都有很大的区别，你不能强迫每个人都跟你使用一样的app，不能强迫每个人都用一样的方法使用同一个app。

所以每个人的skill 一定也是百花齐放的，维护好你的skill，就像维护好你的桌面应用，你的文件树，你的云端资源，你的音乐播放列表一样。

那么有一个很好的同步，分享，迭代skill 的机制或者工具，就能加快你的skill 新陈代谢的速度。管理skill的效率很大程度就决定了你处理任务的效率。

## 孵化prompt

### 第一步：调试你的prompt
不停的基于某个锚点，一直去迭代和优化你的prompt，当任务执行结果不尽如人意时，就去优化他，直到达到你满意的状态。

### 第二步：抽象你的prompt

一个任务的prompt 之于你，和一个可重复执行的prompt 之于你，和一个可分享的prompt 之于团队，有不一样的意义。

每当有一个ai任务发生的时候，就思考以下问题。
- 这个任务是否是**我**经常要重复执行的？
- 这个任务是否是**我的角色**需要重复执行的吗？
- 这个任务过于具体还是过于抽象？
- 如果过于具体，是否可以抽象一层让我的角色来执行？

比如，我今天要对某个产品的用户和使用量进行一定的分析，我编辑好我的prompt，通过几轮问答，终于得到了我想要的答案，为了下次能够节约这些问答的过程，我让claude 帮我生成了一个可复用的prompt，并且保存在我的本地。

但是，即使是重复执行的任务，也有需要被抽象的变量，比如时间。

后来你发现，这个用户分析的prompt，只要稍加修改，（比如用户日志表）就能共享给其它团队的产品角色继续使用，于是你考虑分享你的prompt，不一定是prompt 文件本身，这时候，你只需要分享这一个prompt idea。

### Q：为什么要尽量多的从prompt 向skill 演变？

当我们有许许多多调试的完美的prompt时，怎么去找到，定位到那个合适的prompt，就成了问题了，我不想大海捞针似的在我众多的prompt里不停的ls，cat grep。最简单的方法就是交给Agentic Coding Tool。基于claude code的模式下，那就是skill。

skill 是自动冷加载的，它用很少的token就迅速定位到合适的skill。

### Q：什么样的prompt 适合转为一个skill？

Skill 的黄金标准

一个好的 Skill 应该能回答这个问题：

"如果我写一个脚本来做这件事，输入是什么，输出是什么，步骤是什么？"

如果能清晰回答 → 适合做 Skill
如果回答"看情况" → 不适合做 Skill

## 孵化skill

### 第一步：一个简单的prompt based skill

当你把prompt 作为skill来管理时，你一定已经明白了skill的优点。如果是我，我会把我的所有prompt 都放到skill里。让检索prompt的动作也交给Agentic Coding Tool。

第一步并不需要想太多，当你有一个需要被维护的prompt时，就把它放到skill里吧。

### 第二步：迭代，抽象你的skill
（同，迭代抽象prompt）

### Q：迭代孵化你的skill，需要一些什么？

- 团队共同维护的线上文档
- 支持版本管理
- 团队在此事上的共识
- skill的透明和可读性
  
就skill的透明和可读性来说，我想举例说，我永远不会去用一个我不知道的工具，即使它再有用。如果使用者都不知道这个skill的存在，他可能都想不到要来claude code 来发出第一个提问的动作。
现在这个skill 的透明和可读性，只要打通第一个提问的最后一公里即可，并不需要使用者真的懂skill里的具体内容。比如，我知道有一个jira相关的skill，我知道这件事即可。

- 持续的更新，反馈，监控和清理

正如字面意义所说，如果某些skill过时，常常被误执行，那么它应该被及时清理，如果没有一个很好的反馈+清理的动作，团队将会被无限多的skill给淹没。

## 理想形态的开发流程

这一切猜想，都建立在一个理想，可能存在的世界里。这个开发流程跟我们现有的开发流程有很大的区别。

- 产品从知识库里检索知识，挑选某个需求所需要的知识。
- 产品开始根据一种问答的形式，开始撰写，打磨自己的产品需求。
- 产品继续根据问答的形式，检索需要用到的数据。
- 产品leader拿着这个文档，利用知识库+agent，对文档进行不同方向的验证和review，最终定稿需求文档。
- 开发拿着这个这个定稿，分析现有数据结构，分析代码设计，让agent 生成plan
- review plan和实现，确保符合需求。
- 执行plan，提交到一个github分支，并且创建pr
- 其它开发review pr，copilot review pr

这里面对的每一步，都有不一样的skill，有业务skill，有工具使用的skill，有流程的skill。有多少skill等待着我们去迭代，淘汰。

最后，我打开我的claude，输入`请review 这篇博客`

---

## 结语

Skill 不是一蹴而就的产物，而是在日常工作中不断打磨出来的。从一个临时的 prompt，到一个可复用的模板，再到一个团队共享的 skill——这个演变过程本身就是对工作流程的深度思考。

开始很简单：下次当你发现自己在重复输入类似的 prompt 时，停下来，把它变成一个 skill。这就是你的第一步。